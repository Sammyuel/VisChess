'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HerokuAPIError = undefined;

var _httpCall = require('http-call');

var _httpCall2 = _interopRequireDefault(_httpCall);

var _yubikey = require('./yubikey');

var _yubikey2 = _interopRequireDefault(_yubikey);

var _mutex = require('./mutex');

var _mutex2 = _interopRequireDefault(_mutex);

var _vars = require('./vars');

var _vars2 = _interopRequireDefault(_vars);

var _url = require('url');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HerokuAPIError extends Error {

  constructor(httpError) {
    let options = httpError.body;
    if (!options.message) throw httpError;
    let info = [];
    if (options.id) info.push(`Error ID: ${options.id}`);
    if (options.app && options.app.name) info.push(`App: ${options.app.name}`);
    if (options.url) info.push(`See ${options.url} for more information.`);
    if (info.length) super([options.message, ''].concat(info).join('\n'));else super(options.message);
    this.http = httpError;
    this.body = options;
  }
}

exports.HerokuAPIError = HerokuAPIError;
class Heroku {

  constructor({ config, cli } = {}, options = {}) {
    this.config = config;
    const { CLI } = require('cli-ux');
    this.cli = cli || new CLI({ mock: config.mock });
    if (options.required === undefined) options.required = true;
    options.preauth = options.preauth !== false;
    this.options = options;
    let apiUrl = new _url.URL(_vars2.default.apiUrl);
    let envHeaders = JSON.parse(process.env.HEROKU_HEADERS || '{}');
    this.twoFactorMutex = new _mutex2.default();
    this.preauthPromises = {};
    let auth = this.auth;
    let self = this;
    this.http = class extends _httpCall2.default {
      static get defaultOptions() {
        let opts = {
          ...super.defaultOptions,
          host: apiUrl.host,
          headers: {
            ...super.defaultOptions.headers,
            'user-agent': `heroku-cli/${self.config.version} ${self.config.platform}`,
            accept: 'application/vnd.heroku+json; version=3',
            ...envHeaders
          }
        };
        if (auth) opts.headers.authorization = `Bearer ${auth}`;
        return opts;
      }

      static async twoFactorRetry(err, url, opts = {}, retries = 3) {
        const app = err.body.app ? err.body.app.name : null;
        if (!app || !options.preauth) {
          // flow$ignore
          opts.headers['Heroku-Two-Factor-Code'] = await self.twoFactorPrompt();
          return this.request(url, opts, retries);
        } else {
          // if multiple requests are run in parallel for the same app, we should
          // only preauth for the first so save the fact we already preauthed
          if (!self.preauthPromises[app]) {
            self.preauthPromises[app] = self.twoFactorPrompt().then(factor => self.preauth(app, factor));
          }

          await self.preauthPromises[app];
          return this.request(url, opts, retries);
        }
      }

      static async request(url, opts, retries = 3) {
        retries--;
        try {
          return await super.request(url, opts);
        } catch (err) {
          if (!err.__httpcall) throw err;
          let apiError = new HerokuAPIError(err);
          if (retries > 0) {
            if (apiError.http.statusCode === 403 && apiError.body.id === 'two_factor') {
              return this.twoFactorRetry(apiError, url, opts, retries);
            }
          }
          throw apiError;
        }
      }
    };
  }

  get auth() {
    let auth = process.env.HEROKU_API_KEY;
    if (!auth) {
      const Netrc = require('netrc-parser');
      const netrc = new Netrc();
      auth = netrc.machines[_vars2.default.apiHost].password;
    }
    // TODO: handle required
    return auth;
  }

  twoFactorPrompt() {
    _yubikey2.default.enable();
    return this.twoFactorMutex.synchronize(async () => {
      try {
        let factor = await this.cli.prompt('Two-factor code', { type: 'mask' });
        _yubikey2.default.disable();
        return factor;
      } catch (err) {
        _yubikey2.default.disable();
        throw err;
      }
    });
  }

  preauth(app, factor) {
    return this.put(`/apps/${app}/pre-authorizations`, {
      headers: { 'Heroku-Two-Factor-Code': factor }
    });
  }
  get(url, options = {}) {
    return this.http.get(url, options);
  }
  post(url, options = {}) {
    return this.http.post(url, options);
  }
  put(url, options = {}) {
    return this.http.put(url, options);
  }
  patch(url, options = {}) {
    return this.http.patch(url, options);
  }
  delete(url, options = {}) {
    return this.http.delete(url, options);
  }
  stream(url, options = {}) {
    return this.http.stream(url, options);
  }
  request(url, options = {}) {
    return this.http.request(url, options);
  }
  get defaultOptions() {
    return this.http.defaultOptions;
  }
}
exports.default = Heroku;