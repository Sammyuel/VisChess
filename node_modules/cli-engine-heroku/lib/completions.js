'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TeamCompletion = exports.StageCompletion = exports.StackCompletion = exports.SpaceCompletion = exports.ScopeCompletion = exports.RoleCompletion = exports.RemoteCompletion = exports.RegionCompletion = exports.ProcessTypeCompletion = exports.PipelineCompletion = exports.FileCompletion = exports.DynoSizeCompletion = exports.AppDynoCompletion = exports.AppAddonCompletion = exports.BuildpackCompletion = exports.AppCompletion = exports._herokuGet = undefined;

var _api_client = require('./api_client');

var _api_client2 = _interopRequireDefault(_api_client);

var _app = require('./flags/app');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const oneDay = 60 * 60 * 24;

const _herokuGet = exports._herokuGet = async function (resource, ctx) {
  const heroku = new _api_client2.default({ config: ctx.config });
  let { body: resources } = await heroku.get(`/${resource}`);
  if (typeof resources === 'string') resources = JSON.parse(resources);
  return resources.map(a => a.name).sort();
};

const AppCompletion = exports.AppCompletion = {
  cacheDuration: oneDay,
  options: async ctx => {
    let apps = await _herokuGet('apps', ctx);
    return apps;
  }
};

const BuildpackCompletion = exports.BuildpackCompletion = {
  skipCache: true,
  options: async ctx => {
    return ['heroku/ruby', 'heroku/nodejs', 'heroku/clojure', 'heroku/python', 'heroku/java', 'heroku/gradle', 'heroku/scala', 'heroku/php', 'heroku/go'];
  }
};

const AppAddonCompletion = exports.AppAddonCompletion = {
  cacheDuration: oneDay,
  cacheKey: async ctx => {
    return ctx.flags && ctx.flags.app ? `${ctx.flags.app}_addons` : '';
  },
  options: async ctx => {
    const heroku = new _api_client2.default({ config: ctx.config });
    let addons = ctx.flags && ctx.flags.app ? await heroku.get(`/apps/${ctx.flags.app}/addons`) : [];
    return addons.map(a => a.name).sort();
  }
};

const AppDynoCompletion = exports.AppDynoCompletion = {
  cacheDuration: oneDay,
  cacheKey: async ctx => {
    return ctx.flags && ctx.flags.app ? `${ctx.flags.app}_dynos` : '';
  },
  options: async ctx => {
    const heroku = new _api_client2.default({ config: ctx.config });
    let dynos = ctx.flags && ctx.flags.app ? await heroku.get(`/apps/${ctx.flags.app}/dynos`) : [];
    return dynos.map(a => a.type).sort();
  }
};

const DynoSizeCompletion = exports.DynoSizeCompletion = {
  cacheDuration: oneDay * 90,
  options: async ctx => {
    let sizes = await _herokuGet('dyno-sizes', ctx);
    return sizes;
  }
};

const FileCompletion = exports.FileCompletion = {
  skipCache: true,
  options: async ctx => {
    let files = await _fsExtra2.default.readdir(process.cwd());
    return files;
  }
};

const PipelineCompletion = exports.PipelineCompletion = {
  cacheDuration: oneDay,
  options: async ctx => {
    let pipelines = await _herokuGet('pipelines', ctx);
    return pipelines;
  }
};

const ProcessTypeCompletion = exports.ProcessTypeCompletion = {
  skipCache: true,
  options: async ctx => {
    let types = [];
    let procfile = _path2.default.join(process.cwd(), 'Procfile');
    if (await _fsExtra2.default.exists(procfile)) {
      let buff = await _fsExtra2.default.readFile(procfile);
      types = buff.toString().split('\n').map(s => {
        if (!s) return false;
        let m = s.match(/^([A-Za-z0-9_-]+)/);
        return m ? m[0] : false;
      }).filter(t => t);
    }
    return types;
  }
};

const RegionCompletion = exports.RegionCompletion = {
  cacheDuration: oneDay * 7,
  options: async ctx => {
    let regions = await _herokuGet('regions', ctx);
    return regions;
  }
};

const RemoteCompletion = exports.RemoteCompletion = {
  skipCache: true,
  options: async ctx => {
    let remotes = (0, _app.getGitRemotes)((0, _app.configRemote)());
    return remotes.map(r => r.remote);
  }
};

const RoleCompletion = exports.RoleCompletion = {
  skipCache: true,
  options: async ctx => {
    return ['admin', 'collaborator', 'member', 'owner'];
  }
};

const ScopeCompletion = exports.ScopeCompletion = {
  skipCache: true,
  options: async ctx => {
    return ['global', 'identity', 'read', 'write', 'read-protected', 'write-protected'];
  }
};

const SpaceCompletion = exports.SpaceCompletion = {
  cacheDuration: oneDay,
  options: async ctx => {
    let spaces = await _herokuGet('spaces', ctx);
    return spaces;
  }
};

const StackCompletion = exports.StackCompletion = {
  cacheDuration: oneDay,
  options: async ctx => {
    let stacks = await _herokuGet('stacks', ctx);
    return stacks;
  }
};

const StageCompletion = exports.StageCompletion = {
  skipCache: true,
  options: async ctx => {
    return ['test', 'review', 'development', 'staging', 'production'];
  }
};

const TeamCompletion = exports.TeamCompletion = {
  cacheDuration: oneDay,
  options: async ctx => {
    let teams = await _herokuGet('teams', ctx);
    return teams;
  }
};