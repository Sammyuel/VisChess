"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../base");
function shouldDisplaySpinner(options) {
    return (!process.env.DEBUG &&
        !options.mock &&
        !options.debug &&
        !!process.stdin.isTTY &&
        !!process.stderr.isTTY &&
        !process.env.CI &&
        process.env.TERM !== 'dumb');
}
exports.shouldDisplaySpinner = shouldDisplaySpinner;
class ActionBase extends base_1.Base {
    start(action, status) {
        const task = (this.task = { action, status, active: !!(this.task && this.task.active) });
        this._start();
        task.active = true;
        this.log(task);
    }
    stop(msg = 'done') {
        const task = this.task;
        if (!task) {
            return;
        }
        // TODO: is this right?
        this.status = msg;
        this._stop();
        task.active = false;
        delete this.task;
    }
    get globals() {
        const globals = (global['cli-ux'] = global['cli-ux'] || {});
        globals.action = globals.action || {};
        return globals;
    }
    get task() {
        return this.globals.action.task;
    }
    set task(task) {
        this.globals.action.task = task;
    }
    get running() {
        return !!this.task;
    }
    get status() {
        return this.task ? this.task.status : undefined;
    }
    set status(status) {
        const task = this.task;
        if (!task) {
            return;
        }
        if (task.status === status) {
            return;
        }
        this._updateStatus(status, task.status);
        task.status = status;
        this.log(task);
    }
    pauseAsync(fn, icon) {
        return __awaiter(this, void 0, void 0, function* () {
            const task = this.task;
            const active = task && task.active;
            if (task && active) {
                this._pause(icon);
                task.active = false;
            }
            const ret = yield fn();
            if (task && active) {
                this._resume();
            }
            return ret;
        });
    }
    pause(fn, icon) {
        const task = this.task;
        const active = task && task.active;
        if (task && active) {
            this._pause(icon);
            task.active = false;
        }
        const ret = fn();
        if (task && active) {
            this._resume();
        }
        return ret;
    }
    log({ action, status }) {
        const msg = status ? `${action}... ${status}\n` : `${action}...\n`;
        this.stderr.writeLogFile(msg, true);
    }
    _start() {
        throw new Error('not implemented');
    }
    _stop() {
        throw new Error('not implemented');
    }
    _resume() {
        if (this.task)
            this.start(this.task.action, this.task.status);
    }
    _pause(icon) {
        throw new Error('not implemented');
    }
    _updateStatus(status, prevStatus) { }
}
exports.ActionBase = ActionBase;
