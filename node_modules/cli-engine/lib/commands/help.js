'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _util = require('../util');

var _screen = require('cli-engine-command/lib/screen');

var _plugins = require('../plugins');

var _plugins2 = _interopRequireDefault(_plugins);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trimToMaxLeft(n) {
  let max = parseInt(_screen.stdtermwidth * 0.6);
  return n > max ? max : n;
}

function trimCmd(s, max) {
  if (s.length <= max) return s;
  return `${s.slice(0, max - 1)}\u2026`;
}

function renderList(items) {
  const S = require('string');
  const max = require('lodash.maxby');

  let maxLeftLength = trimToMaxLeft(max(items, '[0].length')[0].length + 1);
  return items.map(i => {
    let left = ` ${i[0]}`;
    let right = i[1];
    if (!right) return left;
    left = `${S(trimCmd(left, maxLeftLength)).padRight(maxLeftLength)}`;
    right = linewrap(maxLeftLength + 2, right);
    return `${left}  ${right}`;
  }).join('\n');
}

function linewrap(length, s) {
  const linewrap = require('@heroku/linewrap');
  return linewrap(length, _screen.stdtermwidth, {
    skipScheme: 'ansi-color'
  })(s).trim();
}

class Help extends _cliEngineCommand2.default {

  async run() {
    this.plugins = new _plugins2.default(this.config);
    await this.plugins.load();
    let cmd = this.config.argv.slice(1).find(arg => !['help', '-h', '--help'].includes(arg));
    if (!cmd) {
      return this.topics();
    }

    const topic = await this.plugins.findTopic(cmd);
    const matchedCommand = await this.plugins.findCachedCommand(cmd);

    if (!topic && !matchedCommand) {
      throw new Error(`command ${cmd} not found`);
    }

    if (matchedCommand) {
      this.out.log(matchedCommand.buildHelp);
    }

    if (topic) {
      const cmds = await this.plugins.commandsForTopic(topic.id);
      let subtopics = await this.plugins.subtopicsForTopic(topic.id);
      if (subtopics && subtopics.length) this.topics(subtopics, topic.id, topic.id.split(':').length + 1);
      if (cmds) this.listCommandsHelp(cmd, cmds);
    }
  }

  topics(ptopics = null, id, offset = 1) {
    let color = this.out.color;
    this.out.log(`${color.bold('Usage:')} ${this.config.bin} ${id || ''}${id ? ':' : ''}COMMAND

Help topics, type ${this.out.color.cmd(this.config.bin + ' help TOPIC')} for more details:\n`);
    let topics = (ptopics || this.plugins.topics).filter(t => {
      if (!t.id) return;
      const subtopic = t.id.split(':')[offset];
      return !t.hidden && !subtopic;
    });
    topics = topics.map(t => [t.id, t.description ? this.out.color.dim(t.description) : null]);
    topics.sort();
    this.out.log(renderList(topics));
    this.out.log();
  }

  listCommandsHelp(topic, commands) {
    commands = commands.filter(c => !c.hidden);
    if (commands.length === 0) return;
    commands.sort((0, _util.compare)('command'));
    let helpCmd = this.out.color.cmd(`${this.config.bin} help ${topic}:COMMAND`);
    this.out.log(`${this.config.bin} ${this.out.color.bold(topic)} commands: (get help with ${helpCmd})`);
    this.out.log(renderList(commands.map(c => c.buildHelpLine)));
    this.out.log();
  }
}
exports.default = Help;
Help.topic = 'help';
Help.description = 'display help';
Help.variableArgs = true;