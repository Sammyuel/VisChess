'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _updater = require('../updater');

var _update = require('./plugins/update');

var _update2 = _interopRequireDefault(_update);

var _hooks = require('../hooks');

var _cliUx = require('cli-ux');

var _cliUx2 = _interopRequireDefault(_cliUx);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli-engine:update');

function brew(...args) {
  const cp = require('child_process');
  debug('brew %o', args);
  return cp.spawnSync('brew', args, { stdio: 'inherit' });
}

const cliBin = global.config ? global.config.bin : 'heroku';

class Update extends _cliEngineCommand2.default {

  async run() {
    // on manual run, also log to file
    if (!this.flags.autoupdate) {
      _cliUx2.default.config.errlog = _path2.default.join(this.config.cacheDir, 'autoupdate');
    }
    this.updater = new _updater.Updater(this.config, this.cli);
    if (this.config.updateDisabled === 'Update CLI with `brew upgrade heroku`') {
      this.migrateBrew();
    } else if (this.config.updateDisabled) {
      this.out.warn(this.config.updateDisabled);
    } else {
      this.out.action.start(`${this.config.name}: Updating CLI`);
      let channel = this.argv[0] || this.config.channel;
      let manifest = await this.updater.fetchManifest(channel);
      if (this.config.version === manifest.version && channel === this.config.channel) {
        if (!process.env.CLI_ENGINE_HIDE_UPDATED_MESSAGE) {
          this.out.action.stop(`already on latest version: ${this.config.version}`);
        }
      } else {
        let { yellow, green } = this.out.color;
        this.out.action.start(`${this.config.name}: Updating CLI from ${green(this.config.version)} to ${green(manifest.version)}${channel === 'stable' ? '' : ' (' + yellow(channel) + ')'}`);
        await this.updater.update(manifest);
        this.out.action.stop();
        try {
          await this.updater.autoupdate(true);
          this.out.exit(0);
        } catch (err) {
          this.out.warn(err, 'post-install autoupdate failed');
        }
      }
    }
    debug('fetch version');
    await this.updater.fetchVersion(true);
    debug('plugins update');
    await _update2.default.run({ ...this.config, argv: [] });
    debug('log chop');
    await this.logChop();
    debug('autocomplete');
    const hooks = new _hooks.Hooks({ config: this.config });
    await hooks.run('update');
    debug('done');
    this.cli.action.stop();
  }

  async logChop() {
    try {
      const logChopper = require('log-chopper').default;
      await logChopper.chop(this.config.errlog);
    } catch (e) {
      debug(e.message);
    }
  }

  migrateBrew() {
    try {
      debug('migrating from brew');
      const fs = require('fs-extra');
      let p = fs.realpathSync('/usr/local/bin/heroku');
      if (p.match(/\/usr\/local\/Cellar\/heroku\/\d+\.\d+\.\d+\//)) {
        // not on private tap, move to it
        this.out.action.start('Upgrading homebrew formula');
        brew('tap', 'heroku/brew');
        brew('upgrade', 'heroku/brew/heroku');
        this.out.action.stop();
      }
    } catch (err) {
      debug(err);
    }
  }
}
exports.default = Update;
Update.topic = 'update';
Update.description = `update the ${cliBin} CLI`;
Update.args = [{ name: 'channel', optional: true }];
Update.flags = {
  autoupdate: _cliEngineCommand.flags.boolean({ hidden: true })
};