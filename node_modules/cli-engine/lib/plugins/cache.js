'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('./plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _manager = require('./manager');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _lock = require('../lock');

var _lock2 = _interopRequireDefault(_lock);

var _cliUx = require('cli-ux');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli:plugincache');

class Cache {

  constructor(config) {
    this.config = config;
    this.cli = new _cliUx.CLI({ mock: config.mock });
  }

  initialize() {
    this._cache = {
      version: this.config.version,
      plugins: {},
      node_version: null
    };
  }

  clear() {
    this._cache = {
      version: this.config.version,
      plugins: {},
      node_version: this._cache.node_version
    };
  }

  get file() {
    return _path2.default.join(this.config.cacheDir, 'plugins.json');
  }
  get cache() {
    if (this._cache) return this._cache;

    try {
      this._cache = _fsExtra2.default.readJSONSync(this.file);
    } catch (err) {
      if (err.code !== 'ENOENT') debug(err);
      this.initialize();
    }
    if (this._cache.version !== this.config.version) {
      this.clear();
    }
    return this._cache;
  }

  plugin(path) {
    return this.cache.plugins[path];
  }

  updatePlugin(path, plugin) {
    this.constructor.updated = true;
    this.cache.plugins[path] = plugin;
  }

  deletePlugin(...paths) {
    for (let path of paths) {
      debug(`clearing cache for ${path}`);
      this.constructor.updated = true;
      delete this.cache.plugins[path];
    }
    this.save();
  }

  async fetch(pluginPath) {
    let c = this.plugin(pluginPath.path);
    if (c) return c;
    try {
      debug('updating cache for ' + pluginPath.path);
      let cachedPlugin = await pluginPath.convertToCached();
      this.updatePlugin(pluginPath.path, cachedPlugin);
      return cachedPlugin;
    } catch (err) {
      if (pluginPath.type === 'builtin') throw err;
      if (await pluginPath.repair(err)) return this.fetch(pluginPath);
      this.cli.warn(`Error parsing plugin ${pluginPath.path}`);
      this.cli.warn(err);
      return {
        name: pluginPath.path,
        path: pluginPath.path,
        version: '',
        commands: [],
        topics: []
      };
    }
  }

  async fetchManagers(...managers) {
    let plugins = [];
    if (this.cache.node_version !== process.version) {
      let lock = new _lock2.default(this.config);

      let downgrade = await lock.upgrade();
      for (let manager of managers) {
        await manager.handleNodeVersionChange();
      }
      await downgrade();

      this.cache.node_version = process.version;
      this.constructor.updated = true;
    }

    for (let manager of managers) {
      let paths = await manager.list();
      for (let path of paths) {
        let plugin = await this.fetch(path);
        if (plugins.find(p => p.name === plugin.name)) continue;
        plugins.push(new _plugin2.default(this.config, path, plugin));
      }
    }

    this.save();

    return plugins;
  }

  save() {
    if (!this.constructor.updated) return;
    try {
      _fsExtra2.default.writeJSONSync(this.file, this.cache);
    } catch (err) {
      this.cli.warn(err);
    }
  }
}
exports.default = Cache;
Cache.updated = false;