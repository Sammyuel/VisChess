'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliUx = require('cli-ux');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli:yarn');

class Yarn {

  constructor(config, cwd) {
    this.config = config;
    this.cli = new _cliUx.CLI({ mock: config.mock });
    this.cwd = cwd;
  }

  get bin() {
    return _path2.default.join(__dirname, '..', '..', 'yarn', `yarn.js`);
  }

  // https://github.com/yarnpkg/yarn/blob/master/src/constants.js#L73-L90
  pathKey(env = process.env) {
    let pathKey = 'PATH';

    // windows calls its path "Path" usually, but this is not guaranteed.
    if (this.config.windows) {
      pathKey = 'Path';
      for (const key in env) {
        if (key.toLowerCase() === 'path') {
          pathKey = key;
        }
      }
    }
    return pathKey;
  }

  // https://github.com/yarnpkg/yarn/blob/master/src/util/execute-lifecycle-script.js#L130-L154
  pathEnv() {
    let pathKey = this.pathKey();
    const pathParts = (process.env[pathKey] || '').split(_path2.default.delimiter);
    pathParts.unshift(_path2.default.dirname(process.execPath));

    const env = {};
    env[pathKey] = pathParts.join(_path2.default.delimiter);
    return env;
  }

  fork(modulePath, args = [], options = {}) {
    const { fork } = require('child_process');
    return new Promise((resolve, reject) => {
      let forked = fork(modulePath, args, options);
      let error = '';

      forked.stdout.setEncoding('utf8');
      forked.stdout.on('data', data => {
        if (this.config.debug) {
          this.cli.stdout.write(data);
        }
      });

      forked.stderr.setEncoding('utf8');
      forked.stderr.on('data', data => {
        if (this.config.debug) {
          this.cli.stderr.write(data);
        }

        error += data;
      });

      forked.on('error', reject);
      forked.on('exit', code => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`yarn ${args.join(' ')} exited with code ${code}\n${error}`));
        }
      });

      // Fix windows bug with node-gyp hanging for input forever
      if (this.config.windows) {
        forked.stdin.write('\n');
      }
    });
  }

  async exec(args = []) {
    if (args.length !== 0) await this.checkForYarnLock();
    args = args.concat(['--non-interactive', ...Yarn.extraOpts, ...this.proxyArgs()]);
    if (global.yarnCacheDir !== false) {
      let cacheDir = global.yarnCacheDir || _path2.default.join(this.config.cacheDir, 'yarn');
      args = args.concat([`--mutex=file:${cacheDir}`, `--cache-folder=${cacheDir}`]);
    }

    let options = {
      cwd: this.cwd,
      stdio: [null, null, null, 'ipc'],
      env: {
        ...process.env,
        ...this.pathEnv(),
        YARN_REGISTRY: this.config.npmRegistry
      }
    };

    debug(`${options.cwd}: ${this.bin} ${args.join(' ')}`);
    try {
      await this.fork(this.bin, args, options);
      debug('done');
    } catch (err) {
      // TODO: https://github.com/yarnpkg/yarn/issues/2191
      let networkConcurrency = '--network-concurrency=1';
      if (err.message.includes('EAI_AGAIN') && !args.includes(networkConcurrency)) {
        debug('EAI_AGAIN');
        return this.exec(args.concat(networkConcurrency));
      } else throw err;
    }
  }

  async checkForYarnLock() {
    // add yarn lockfile if it does not exist
    if (this.cwd && !_fsExtra2.default.existsSync(_path2.default.join(this.cwd, 'yarn.lock'))) {
      await this.exec();
    }
  }

  proxyArgs() {
    let args = [];
    let http = process.env.http_proxy || process.env.HTTP_PROXY;
    let https = process.env.https_proxy || process.env.HTTPS_PROXY;
    if (http) args.push(`--proxy=${http}`);
    if (https) args.push(`--https-proxy=${https}`);
    return args;
  }
}
exports.default = Yarn;
Yarn.extraOpts = [];