'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliEngineHeroku = require('cli-engine-heroku');

class Status extends _cliEngineHeroku.Command {

  async run() {
    const moment = require('moment');
    const maxBy = require('lodash.maxby');
    const padEnd = require('lodash.padend');
    const sprintf = require('sprintf-js').sprintf;
    const apiPath = '/api/v4/current-status';

    const capitalize = str => str.substr(0, 1).toUpperCase() + str.substr(1);
    const printStatus = status => {
      const colorize = this.out.color[status];
      let message = capitalize(status);

      if (status === 'green') {
        message = 'No known issues at this time.';
      }
      return colorize(message);
    };

    let host = process.env.HEROKU_STATUS_HOST || 'https://status.heroku.com';
    let { body } = await this.http.get(host + apiPath);

    if (this.flags.json) {
      this.out.styledJSON(body);
      return;
    }

    for (let item of body.status) {
      var message = printStatus(item.status);

      this.out.log(sprintf('%-10s %s', item.system + ':', message));
    }

    for (let incident of body.incidents) {
      this.out.log();
      this.out.styledHeader(`${incident.title} ${this.out.color.yellow(moment(incident.created_at).format('LT'))} ${this.out.color.cyan(incident.full_url)}`);

      let padding = maxBy(incident.updates, 'update_type.length').update_type.length + 1;
      for (let u of incident.updates) {
        this.out.log(`${this.out.color.yellow(padEnd(u.update_type, padding))} ${moment(u.updated_at).format('LT')} (${moment(u.updated_at).fromNow()})`);
        this.out.log(`${u.contents}\n`);
      }
    }
  }
}
exports.default = Status;
Status.topic = 'status';
Status.description = 'display current status of Heroku platform';
Status.flags = {
  json: _cliEngineHeroku.flags.boolean({ description: 'output in json format' })
};