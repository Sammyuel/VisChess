'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomColors = undefined;

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _linewrap = require('./linewrap');

var _linewrap2 = _interopRequireDefault(_linewrap);

var _screen = require('./screen');

var _action = require('./action');

var _supportsColor = require('supports-color');

var _supportsColor2 = _interopRequireDefault(_supportsColor);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _cliEngineConfig = require('cli-engine-config');

var _prompt = require('./prompt');

var _prompt2 = _interopRequireDefault(_prompt);

var _stream = require('./stream');

var _stream2 = _interopRequireDefault(_stream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ExitError extends Error {
  constructor(code) {
    super(`Exited with code: ${code}`);
    this.code = code;
  }

}

const CustomColors = exports.CustomColors = {
  supports: _supportsColor2.default,
  // map gray -> dim because it's not solarized compatible
  gray: s => _chalk2.default.dim(s),
  grey: s => _chalk2.default.dim(s),
  attachment: s => _chalk2.default.cyan(s),
  addon: s => _chalk2.default.yellow(s),
  configVar: s => _chalk2.default.green(s),
  release: s => _chalk2.default.blue.bold(s),
  cmd: s => _chalk2.default.cyan.bold(s),
  app: s => CustomColors.heroku(`⬢ ${s}`),
  heroku: s => {
    if (!CustomColors.supports) return s;
    let has256 = CustomColors.supports.has256 || (process.env.TERM || '').indexOf('256') !== -1;
    return has256 ? '\u001b[38;5;104m' + s + _chalk2.default.styles.reset.open : _chalk2.default.magenta(s);
  }
};

if (['false', '0'].indexOf((process.env.COLOR || '').toLowerCase()) !== -1) CustomColors.supports = false;

function wrap(msg) {
  return (0, _linewrap2.default)(6, _screen.errtermwidth, {
    skipScheme: 'ansi-color',
    skip: /^\$ .*$/
  })(msg);
}

function bangify(msg, c) {
  let lines = msg.split('\n');
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    lines[i] = ' ' + c + line.substr(2, line.length);
  }
  return lines.join('\n');
}

function getErrorMessage(err) {
  let message;
  if (err.body) {
    // API error
    if (err.body.message) {
      message = _util2.default.inspect(err.body.message);
    } else if (err.body.error) {
      message = _util2.default.inspect(err.body.error);
    }
  }
  // Unhandled error
  if (err.message && err.code) {
    message = `${_util2.default.inspect(err.code)}: ${err.message}`;
  } else if (err.message) {
    message = err.message;
  }
  return message || _util2.default.inspect(err);
}

const arrow = process.platform === 'win32' ? '!' : '▸';

class Output {
  constructor(options = {}) {
    this.mock = false;

    this.mock = options.mock;
    this.config = (0, _cliEngineConfig.buildConfig)(options.config);
    this.stdout = new _stream2.default(process.stdout, this);
    this.stderr = new _stream2.default(process.stderr, this);
    this.action = (0, _action.shouldDisplaySpinner)(this) ? new _action.SpinnerAction(this) : new _action.SimpleAction(this);
    if (this.mock) _chalk2.default.enabled = CustomColors.supports = false;
    this.prompter = new _prompt2.default(this);
  }

  get color() {
    return new Proxy(_chalk2.default, {
      get: (chalk, name) => {
        if (CustomColors[name]) return CustomColors[name];
        return chalk[name];
      }
    });
  }

  async done(...rest) {
    this.action.stop();
  }

  log(data, ...args) {
    this.stdout.log(data, ...args);
  }

  styledJSON(obj) {
    let json = JSON.stringify(obj, null, 2);
    if (CustomColors.supports) {
      let cardinal = require('cardinal');
      let theme = require('cardinal/themes/jq');
      this.log(cardinal.highlight(json, { json: true, theme: theme }));
    } else {
      this.log(json);
    }
  }

  styledHeader(header) {
    this.log(this.color.dim('=== ') + this.color.bold(header));
  }

  styledObject(obj, keys) {
    const util = require('util');
    let keyLengths = Object.keys(obj).map(key => key.toString().length);
    let maxKeyLength = Math.max.apply(Math, keyLengths) + 2;
    function pp(obj) {
      if (typeof obj === 'string' || typeof obj === 'number') {
        return obj;
      } else if (typeof obj === 'object') {
        return Object.keys(obj).map(k => k + ': ' + util.inspect(obj[k])).join(', ');
      } else {
        return util.inspect(obj);
      }
    }
    let logKeyValue = (key, value) => {
      this.log(`${this.color.blue(key)}:` + ' '.repeat(maxKeyLength - key.length - 1) + pp(value));
    };
    for (var key of keys || Object.keys(obj).sort()) {
      let value = obj[key];
      if (Array.isArray(value)) {
        if (value.length > 0) {
          logKeyValue(key, value[0]);
          for (var e of value.slice(1)) {
            this.log(' '.repeat(maxKeyLength) + pp(e));
          }
        }
      } else if (value !== null && value !== undefined) {
        logKeyValue(key, value);
      }
    }
  }

  /**
   * inspect an object for debugging
   */
  inspect(obj, opts = {}) {
    this.action.pause(() => {
      console.dir(obj, Object.assign({ colors: true }, opts));
    });
  }

  debug(obj) {
    if (this.config.debug) this.action.pause(() => console.log(obj));
  }

  get errlog() {
    return _path2.default.join(this.config.cacheDir, 'error.log');
  }
  get autoupdatelog() {
    return _path2.default.join(this.config.cacheDir, 'autoupdate.log');
  }

  error(err, exitCode = 1) {
    if (this.mock && typeof err !== 'string' && exitCode !== false) throw err;
    try {
      if (typeof err === 'string') err = new Error(err);
      this.logError(err);
      if (this.action.task) this.action.stop(this.color.bold.red('!'));
      if (this.config.debug) {
        this.stderr.log(err.stack || _util2.default.inspect(err));
      } else {
        this.stderr.log(bangify(wrap(getErrorMessage(err)), this.color.red(arrow)));
      }
    } catch (e) {
      console.error('error displaying error');
      console.error(e);
      console.error(err);
    }
    if (exitCode !== false) this.exit(exitCode);
  }

  warn(err, prefix) {
    this.action.pause(() => {
      try {
        prefix = prefix ? `${prefix} ` : '';
        err = typeof err === 'string' ? new Error(err) : err;
        this.logError(err);
        if (this.config.debug) process.stderr.write(`WARNING: ${prefix}`) && this.stderr.log(err.stack || _util2.default.inspect(err));else this.stderr.log(bangify(wrap(prefix + getErrorMessage(err)), this.color.yellow(arrow)));
      } catch (e) {
        console.error('error displaying warning');
        console.error(e);
        console.error(err);
      }
    }, this.color.bold.yellow('!'));
  }

  logError(err) {
    (0, _stream.logToFile)(_util2.default.inspect(err) + '\n', this.errlog);
  }

  prompt(name, options) {
    return this.prompter.prompt(name, options);
  }

  table(data, options) {
    let table = require('./table');
    return table(this, data, options);
  }

  exit(code = 0) {
    if (this.config.debug) console.error(`Exiting with code: ${code}`);
    if (this.mock) throw new ExitError(code);else process.exit(code);
  }
}
exports.default = Output;