'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PromptMaskError = undefined;

var _ansiEscapes = require('ansi-escapes');

var _ansiEscapes2 = _interopRequireDefault(_ansiEscapes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PromptMaskError extends Error {}

exports.PromptMaskError = PromptMaskError;
class Prompter {

  constructor(out) {
    this.out = out;
  }

  prompt(name, options) {
    options = options || {};
    options.name = name;
    options.prompt = name ? this.out.color.dim(`${name}: `) : this.out.color.dim('> ');
    let isTTY = process.env.TERM !== 'dumb' && process.stdin.isTTY;
    return this.out.action.pause(() => {
      if (options.mask || options.hide) {
        if (!isTTY) {
          return Promise.reject(new PromptMaskError(`CLI needs to prompt for ${options.name || options.prompt || 'unknown'} but stdin is not a tty.`));
        }

        return this.promptMasked(options);
      } else {
        return new Promise(resolve => {
          process.stdin.setEncoding('utf8');
          this.out.stderr.write(options.prompt || '>');
          process.stdin.resume();
          process.stdin.once('data', function (data) {
            process.stdin.pause();
            data = data.trim();
            if (data === '') {
              resolve(this.prompt(name));
            } else {
              resolve(data);
            }
          });
        });
      }
    });
  }

  promptMasked(options) {
    return new Promise((resolve, reject) => {
      let stdin = process.stdin;
      let stderr = process.stderr;
      let input = '';
      stdin.setEncoding('utf8');
      stderr.write(_ansiEscapes2.default.eraseLine);
      stderr.write(_ansiEscapes2.default.cursorLeft);
      this.out.stderr.write(options.prompt || '>');
      stdin.resume();stdin.setRawMode(true);

      function stop() {
        if (!options.hide) {
          stderr.write(_ansiEscapes2.default.cursorHide + _ansiEscapes2.default.cursorLeft + options.prompt + input.replace(/./g, '*') + '\n' + _ansiEscapes2.default.cursorShow);
        } else {
          stderr.write('\n');
        }
        stdin.removeListener('data', fn);stdin.setRawMode(false);
        stdin.pause();
      }

      function enter() {
        if (input.length === 0) return;
        stop();
        resolve(input);
      }

      function ctrlc() {
        reject(new Error('SIGINT'));
        stop();
      }

      function backspace() {
        if (input.length === 0) return;
        input = input.substr(0, input.length - 1);
        stderr.write(_ansiEscapes2.default.cursorBackward(1));
        stderr.write(_ansiEscapes2.default.eraseEndLine);
      }

      function newchar(c) {
        input += c;
        stderr.write(options.hide ? '*'.repeat(c.length) : c);
      }

      let fn = function (c) {
        switch (c) {
          case '\u0004': // Ctrl-d
          case '\r':
          case '\n':
            return enter();
          case '\u0003':
            // Ctrl-c
            return ctrlc();
          default:
            // backspace
            if (c.charCodeAt(0) === 127) return backspace();else return newchar(c);
        }
      };
      stdin.on('data', fn);
    });
  }
}
exports.default = Prompter;