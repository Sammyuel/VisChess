'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTTPError = undefined;
exports.get = get;
exports.post = post;
exports.put = put;
exports.patch = patch;
exports.hdelete = hdelete;
exports.stream = stream;
exports.request = request;

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _package = require('../package.json');

var _package2 = _interopRequireDefault(_package);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _proxy = require('./proxy');

var _proxy2 = _interopRequireDefault(_proxy);

var _isStream = require('is-stream');

var _isStream2 = _interopRequireDefault(_isStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('http');

const debugHeaders = require('debug')('http:headers');
const debugBody = require('debug')('http:body');

function concat(stream) {
  return new Promise(resolve => {
    let strings = [];
    stream.on('data', data => strings.push(data));
    stream.on('end', () => resolve(strings.join('')));
  });
}

/**
 * @typedef {Object} HTTPRequestOptions
 * @property {Object.<string, string>} headers - request headers
 * @property {string} method - request method (GET/POST/etc)
 * @property {(string)} body - request body. Sets content-type to application/json and stringifies when object
 * @property {(boolean)} partial - do not make continuous requests while receiving a Next-Range header for GET requests
 * @property {(number)} port - port to use
 */


function caseInsensitiveObject() {
  let lowercaseKey = k => typeof k === 'string' ? k.toLowerCase() : k;
  return new Proxy({}, {
    get: (t, k) => {
      k = lowercaseKey(k);
      return t[k];
    },
    set: (t, k, v) => {
      k = lowercaseKey(k);
      t[k] = v;
      return true;
    },
    deleteProperty: (t, k) => {
      k = lowercaseKey(k);
      if (k in t) return false;
      return delete t[k];
    },
    has: function (t, k) {
      k = lowercaseKey(k);
      return k in t;
    }
  });
}

function lowercaseHeaders(headers) {
  let newHeaders = caseInsensitiveObject();
  for (let [k, v] of Object.entries(headers)) {
    newHeaders[k] = v;
  }
  return newHeaders;
}

/**
 * Utility for simple HTTP calls
 * @class
 */
class HTTP {
  /**
   * make an http GET request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.get('https://google.com')
   * ```
   */
  static get(url, options = {}) {
    return this.request(url, { ...options, method: 'GET' });
  }

  /**
   * make an http POST request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.post('https://google.com')
   * ```
   */
  static post(url, options = {}) {
    return this.request(url, { ...options, method: 'POST' });
  }

  /**
   * make an http PUT request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.put('https://google.com')
   * ```
   */
  static put(url, options = {}) {
    return this.request(url, { ...options, method: 'PUT' });
  }

  /**
   * make an http PATCH request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.patch('https://google.com')
   * ```
   */
  static async patch(url, options = {}) {
    return this.request(url, { ...options, method: 'PATCH' });
  }

  /**
   * make an http DELETE request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.delete('https://google.com')
   * ```
   */
  static async delete(url, options = {}) {
    return this.request(url, { ...options, method: 'DELETE' });
  }

  /**
   * make a streaming request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * let {response} = await http.get('https://google.com')
   * response.on('data', console.log)
   * ```
   */
  static stream(url, options = {}) {
    return this.request(url, { ...options, raw: true });
  }

  static async request(url, options = {}) {
    let http = new this(url, options);
    await http._request();
    return http;
  }

  static defaults(options = {}) {
    return class CustomHTTP extends HTTP {
      static get defaultOptions() {
        return {
          ...super.defaultOptions,
          ...options
        };
      }
    };
  }

  static get defaultOptions() {
    return {
      method: 'GET',
      host: 'localhost',
      protocol: 'https:',
      path: '/',
      raw: false,
      partial: false,
      headers: {
        'user-agent': `${_package2.default.name}/${_package2.default.version} node-${process.version}`
      }
    };
  }

  // instance properties

  get method() {
    return this.options.method;
  }
  get statusCode() {
    if (!this.response) return 0;
    return this.response.statusCode;
  }
  get secure() {
    return this.options.protocol === 'https:';
  }
  get url() {
    return `${this.options.protocol}//${this.options.host}${this.options.path}`;
  }
  set url(input) {
    let u = _url2.default.parse(input);
    this.options.protocol = u.protocol || this.options.protocol;
    this.options.host = u.hostname || this.constructor.defaultOptions.host || 'localhost';
    this.options.path = u.path || '/';
    this.options.agent = this.options.agent || _proxy2.default.agent(this.secure);
    this.options.port = parseInt(u.port || this.constructor.defaultOptions.port || (this.secure ? 443 : 80));
  }
  get headers() {
    if (!this.response) return {};
    return this.response.headers;
  }
  get partial() {
    if (this.method !== 'GET' || this.options.partial) return true;
    return !(this.headers['next-range'] && this.body instanceof Array);
  }
  constructor(url, options = {}) {
    this.options = {
      ...this.constructor.defaultOptions,
      ...options,
      headers: lowercaseHeaders({
        ...this.constructor.defaultOptions.headers,
        ...options.headers
      })
    };
    if (!url) throw new Error('no url provided');
    this.url = url;
    if (this.options.body) this._parseBody(this.options.body);
  }

  async _request() {
    this._debugRequest();
    try {
      this.response = await this._performRequest();
    } catch (err) {
      debug(err);
      return this._maybeRetry(err);
    }
    if (this._shouldParseResponseBody) await this._parse();
    this._debugResponse();
    if (this._responseRedirect) return this._redirect();
    if (!this._responseOK) {
      throw new HTTPError(this);
    }
    if (!this.partial) await this._getNextRange();
  }

  async _redirect() {
    if (!this._redirectRetries) this._redirectRetries = 0;
    this._redirectRetries++;
    if (this._redirectRetries > 10) throw new Error(`Redirect loop at ${this.url}`);
    if (!this.headers.location) throw new Error('Redirect with no location header');
    this.url = this.headers.location;
    await this._request();
  }

  async _maybeRetry(err) {
    if (!this._errorRetries) this._errorRetries = 0;
    this._errorRetries++;
    const allowed = err => {
      if (this._errorRetries > 5) return false;
      if (!err.code) return false;
      if (err.code === 'ENOTFOUND') return true;
      return require('is-retry-allowed')(err);
    };
    if (allowed(err)) {
      let noise = Math.random() * 100;
      await this._wait((1 << this._errorRetries) * 100 + noise);
      await this._request();
      return;
    }
    throw err;
  }

  _debugRequest() {
    if (this.options.agent) debug('proxy: %o', this.options.agent.options);
    debug('--> %s %s', this.options.method, this.url);
    debugHeaders(this._redactedHeaders(this.options.headers));
    if (this.options.body) debugBody(this.options.body);
  }

  _debugResponse() {
    debug('<-- %s %s %s', this.method, this.url, this.statusCode);
    debugHeaders(this._redactedHeaders(this.headers));
    if (this.body) debugBody(this.body);
  }

  _performRequest() {
    return new Promise((resolve, reject) => {
      this.request = this._http.request(this.options, resolve);
      this.request.on('error', reject);
      if (this.options.body && _isStream2.default.readable(this.options.body)) {
        this.options.body.pipe(this.request);
      } else {
        this.request.end(this.options.body);
      }
    });
  }

  async _parse() {
    this.body = await concat(this.response);
    let json = this.headers['content-type'] === 'application/json';
    if (json) this.body = JSON.parse(this.body);
  }

  _parseBody(body) {
    if (_isStream2.default.readable(body)) {
      this.options.body = body;
      return;
    }
    if (!this.options.headers['content-type']) {
      this.options.headers['content-type'] = 'application/json';
    }

    if (this.options.headers['content-type'] === 'application/json') {
      this.options.body = JSON.stringify(body);
    } else {
      this.options.body = body;
    }
    this.options.headers['content-length'] = Buffer.byteLength(this.options.body).toString();
  }

  async _getNextRange() {
    this.options.headers['range'] = this.headers['next-range'];
    let prev = this.body;
    await this._request();
    this.body = prev.concat(this.body);
  }

  _redactedHeaders(headers) {
    headers = { ...headers };
    if (headers.authorization) headers.authorization = '[REDACTED]';
    return headers;
  }

  get _http() {
    return this.secure ? _https2.default : _http2.default;
  }

  get _responseOK() {
    if (!this.response) return false;
    return this.statusCode >= 200 && this.statusCode < 300;
  }

  get _responseRedirect() {
    if (!this.response) return false;
    return this.statusCode >= 300 && this.statusCode < 400;
  }

  get _shouldParseResponseBody() {
    return !this._responseOK || !this.options.raw && this._responseOK;
  }

  _wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

exports.default = HTTP;
class HTTPError extends Error {

  constructor(http) {
    let message;
    if (typeof http.body === 'string' || typeof http.body.message === 'string') message = http.body.message || http.body;else message = _util2.default.inspect(http.body);
    super(`HTTP Error ${http.statusCode} for ${http.method} ${http.url}\n${message}`);
    this.__httpcall = true;
    this.statusCode = http.statusCode;
    this.http = http;
    this.body = http.body;
  }
}

exports.HTTPError = HTTPError; // common/s helpers

function get(url, options = {}) {
  return HTTP.get(url, options);
}
function post(url, options = {}) {
  return HTTP.post(url, options);
}
function put(url, options = {}) {
  return HTTP.put(url, options);
}
function patch(url, options = {}) {
  return HTTP.patch(url, options);
}
function hdelete(url, options = {}) {
  return HTTP.delete(url, options);
}
function stream(url, options = {}) {
  return HTTP.stream(url, options);
}
function request(url, options = {}) {
  return HTTP.request(url, options);
}