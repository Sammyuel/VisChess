"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const chalk = require("chalk");
const base_1 = require("./base");
const exit_error_1 = require("./exit_error");
const stream_1 = require("./stream");
const screen_1 = require("./screen");
const config_1 = require("./config");
const arrow = process.platform === 'win32' ? ' !' : ' â–¸';
function bangify(msg, c) {
    const lines = msg.split('\n');
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        lines[i] = c + line.substr(2, line.length);
    }
    return lines.join('\n');
}
function getErrorMessage(err) {
    let message;
    if (err.body) {
        // API error
        if (err.body.message) {
            message = util.inspect(err.body.message);
        }
        else if (err.body.error) {
            message = util.inspect(err.body.error);
        }
    }
    // Unhandled error
    if (err.message && err.code) {
        message = `${util.inspect(err.code)}: ${err.message}`;
    }
    else if (err.message) {
        message = err.message;
    }
    return message || util.inspect(err);
}
function wrap(msg) {
    const linewrap = require('@heroku/linewrap');
    return linewrap(6, screen_1.default.errtermwidth, {
        skip: /^\$ .*$/,
        skipScheme: 'ansi-color',
    })(msg);
}
class Errors extends base_1.Base {
    handleUnhandleds() {
        process.on('unhandledRejection', (reason, p) => {
            this.fatal(reason, { context: 'Promise unhandledRejection' });
        });
        process.on('uncaughtException', error => {
            this.fatal(error, { context: 'Error uncaughtException' });
        });
    }
    error(err, options) {
        if (typeof options === 'string')
            options = { context: options };
        options = options || {};
        if (!options.severity)
            options.severity = 'error';
        if (options.exitCode === undefined)
            options.exitCode = 1;
        if (options.severity !== 'warn' && config_1.Config.mock && typeof err !== 'string' && options.exitCode !== false)
            throw err;
        try {
            if (typeof err === 'string')
                err = new Error(err);
            const prefix = options.context ? `${options.context}: ` : '';
            this.logError(err);
            if (config_1.Config.debug) {
                this.stderr.write(`${options.severity.toUpperCase()}: ${prefix}`);
                this.stderr.log(err.stack || util.inspect(err));
            }
            else {
                let bang = chalk.red(arrow);
                if (options.severity === 'fatal')
                    bang = chalk.bgRed.bold.white(' FATAL ');
                if (options.severity === 'warn')
                    bang = chalk.yellow(arrow);
                this.stderr.log(bangify(wrap(prefix + getErrorMessage(err)), bang));
            }
        }
        catch (e) {
            console.error('error displaying error');
            console.error(e);
            console.error(err);
        }
        if (options.exitCode !== false)
            this.exit(options.exitCode);
    }
    fatal(err, options = {}) {
        options.severity = 'fatal';
        this.error(err, options);
    }
    warn(err, options = {}) {
        if (typeof options === 'string')
            options = { context: options };
        options.exitCode = false;
        options.severity = 'warn';
        this.error(err, options);
    }
    exit(code = 0) {
        if (config_1.Config.debug) {
            console.error(`Exiting with code: ${code}`);
        }
        if (config_1.Config.mock) {
            throw new exit_error_1.ExitError(code, this.stdout.output, this.stderr.output);
        }
        else {
            process.exit(code);
        }
    }
    logError(err) {
        if (!config_1.Config.errlog)
            return;
        stream_1.StreamOutput.logToFile(util.inspect(err) + '\n', config_1.Config.errlog);
    }
}
exports.Errors = Errors;
