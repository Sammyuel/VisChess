"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const prompt_1 = require("./prompt");
const errors_1 = require("./errors");
const spinner_1 = require("./action/spinner");
const simple_1 = require("./action/simple");
const base_1 = require("./action/base");
const base_2 = require("./base");
const config_1 = require("./config");
const chalk = require("chalk");
class CLI extends base_2.Base {
    constructor() {
        super();
        if (config_1.Config.mock)
            chalk.enabled = false;
    }
    get Prompt() {
        if (!this._prompt) {
            this._prompt = new prompt_1.Prompt();
        }
        return this._prompt;
    }
    get Errors() {
        if (!this._errors) {
            this._errors = new errors_1.Errors();
        }
        return this._errors;
    }
    get action() {
        if (!this._action) {
            this._action = base_1.shouldDisplaySpinner() ? new spinner_1.SpinnerAction() : new simple_1.SimpleAction();
        }
        return this._action;
    }
    prompt(name, options = {}) {
        return this.action.pauseAsync(() => {
            return this.Prompt.prompt(name, options);
        }, chalk.cyan('?'));
    }
    log(data, ...args) {
        this.action.pause(() => {
            return this.stdout.log(data, ...args);
        });
    }
    warn(err, options = {}) {
        this.action.pause(() => {
            return this.Errors.warn(err, options);
        }, chalk.bold.yellow('!'));
    }
    error(err, options = {}) {
        this.action.pause(() => {
            return this.Errors.error(err, options);
        }, chalk.bold.red('!'));
    }
    exit(code = 1) {
        this.Errors.exit(code);
    }
    table(data, options) {
        let table = require('./table');
        return table(this, data, options);
    }
    styledJSON(obj) {
        let json = JSON.stringify(obj, null, 2);
        if (chalk.enabled) {
            let cardinal = require('cardinal');
            let theme = require('cardinal/themes/jq');
            this.log(cardinal.highlight(json, { json: true, theme: theme }));
        }
        else {
            this.log(json);
        }
    }
    styledHeader(header) {
        this.log(chalk.dim('=== ') + chalk.bold(header));
    }
    styledObject(obj, keys) {
        const util = require('util');
        let keyLengths = Object.keys(obj).map(key => key.toString().length);
        let maxKeyLength = Math.max.apply(Math, keyLengths) + 2;
        function pp(obj) {
            if (typeof obj === 'string' || typeof obj === 'number') {
                return obj;
            }
            else if (typeof obj === 'object') {
                return Object.keys(obj)
                    .map(k => k + ': ' + util.inspect(obj[k]))
                    .join(', ');
            }
            else {
                return util.inspect(obj);
            }
        }
        let logKeyValue = (key, value) => {
            this.log(`${chalk.blue(key)}:` + ' '.repeat(maxKeyLength - key.length - 1) + pp(value));
        };
        for (var key of keys || Object.keys(obj).sort()) {
            let value = obj[key];
            if (Array.isArray(value)) {
                if (value.length > 0) {
                    logKeyValue(key, value[0]);
                    for (var e of value.slice(1)) {
                        this.log(' '.repeat(maxKeyLength) + pp(e));
                    }
                }
            }
            else if (value !== null && value !== undefined) {
                logKeyValue(key, value);
            }
        }
    }
    /**
     * puts in a handler for process.on('uncaughtException') and process.on('unhandledRejection')
     */
    handleUnhandleds() {
        this.Errors.handleUnhandleds();
    }
    /**
     * cleanup any outstanding output like actions that need to be stopped
     */
    done() {
        this.action.stop();
    }
}
exports.CLI = CLI;
exports.cli = new CLI();
exports.default = exports.cli;
