'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.app = app;
exports.remote = remote;

var _vars = require('../vars');

var _vars2 = _interopRequireDefault(_vars);

require('cli-engine-command/lib/flags');

var _git = require('../git');

var _git2 = _interopRequireDefault(_git);

var _api_client = require('../api_client');

var _api_client2 = _interopRequireDefault(_api_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MultipleRemotesError extends Error {
  constructor(gitRemotes) {
    super(`Multiple apps in git remotes
  Usage: --remote ${gitRemotes[1].remote}
     or: --app ${gitRemotes[1].app}
  Your local git repository has more than 1 app referenced in git remotes.
  Because of this, we can't determine which app you want to run this command against.
  Specify the app you want with --app or --remote.
  Heroku remotes in repo:
  ${gitRemotes.map(r => `${r.app} (${r.remote})`).join('\n')}

  https://devcenter.heroku.com/articles/multiple-environments`);
  }
}

function app(options = {}) {
  return {
    char: 'a',
    description: 'app to run command against',
    parse: (input, cmd) => {
      const envApp = process.env.HEROKU_APP;
      if (cmd && cmd.flags.app) return cmd.flags.app;
      if (input) return input;
      if (envApp) return envApp;
      if (cmd) {
        let gitRemotes = getGitRemotes(cmd.flags.remote || configRemote());
        if (gitRemotes.length === 1) return gitRemotes[0].app;
        if (cmd.flags.remote && gitRemotes.length === 0) {
          throw new Error(`remote ${cmd.flags.remote} not found in git remotes`);
        }
        if (gitRemotes.length > 1 && options.required) {
          throw new MultipleRemotesError(gitRemotes);
        }
      }
      if (options.required) throw new Error('No app specified');
    },
    completion: {
      cacheDuration: 60 * 60 * 24, // 1 day
      options: async ctx => {
        const heroku = new _api_client2.default({ out: ctx.out });
        let { body: apps } = await heroku.get('/apps');
        return apps.map(a => a.name).sort();
      }
    },
    ...options
  };
}

function remote(options = {}) {
  return {
    char: 'r',
    description: 'git remote of app to use',
    parse: v => v,
    ...options
  };
}

function configRemote() {
  let git = new _git2.default();
  try {
    return git.exec('config heroku.remote').trim();
  } catch (err) {}
}

function getGitRemotes(onlyRemote) {
  let git = new _git2.default();
  let appRemotes = [];
  let remotes = [];
  try {
    remotes = git.remotes;
  } catch (err) {}
  for (let remote of remotes) {
    if (onlyRemote && remote.name !== onlyRemote) continue;
    for (let prefix of _vars2.default.gitPrefixes) {
      const suffix = '.git';
      let match = remote.url.match(`${prefix}(.*)${suffix}`);
      if (!match) continue;
      appRemotes.push({
        remote: remote.name,
        app: match[1]
      });
    }
  }
  return appRemotes;
}