/// <reference types="lodash" />
import lodash = require('lodash');
declare const _default: {
    readonly ary: (func: (...args: any[]) => any, n?: number | undefined) => (...args: any[]) => any;
    readonly compact: <T>(array: ArrayLike<false | "" | 0 | T | null | undefined> | null | undefined) => T[];
    readonly get: {
        <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey];
        <TObject extends object, TKey extends keyof TObject>(object: TObject | null | undefined, path: TKey | [TKey]): TObject[TKey] | undefined;
        <TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject | null | undefined, path: TKey | [TKey], defaultValue: TDefault): TDefault | TObject[TKey];
        <TDefault>(object: null | undefined, path: lodash.Many<PropertyKey>, defaultValue: TDefault): TDefault;
        (object: null | undefined, path: lodash.Many<PropertyKey>): undefined;
        (object: any, path: lodash.Many<PropertyKey>, defaultValue?: any): any;
    };
    readonly identity: {
        <T>(value: T): T;
        (): undefined;
    };
    readonly mapValues: {
        <T extends object, TResult>(obj: T | null | undefined, callback: lodash.ObjectIterator<T, TResult>): {
            [P in keyof T]: TResult;
        };
        <T extends object>(obj: T | null | undefined, iteratee: object): {
            [P in keyof T]: boolean;
        };
        <T, TKey extends keyof T>(obj: lodash.Dictionary<T> | null | undefined, iteratee: TKey): lodash.Dictionary<T[TKey]>;
        <T extends object, TKey extends keyof T>(obj: T | null | undefined, iteratee: string): {
            [P in keyof T]: any;
        };
        <TResult>(obj: string | null | undefined, callback: lodash.StringIterator<TResult>): lodash.NumericDictionary<TResult>;
        <T>(obj: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<T>;
        <T extends object>(obj: T): T;
        <T extends object>(obj: T | null | undefined): {} | T;
        (obj: string | null | undefined): lodash.NumericDictionary<string>;
    };
    readonly maxBy: <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T | undefined;
    readonly padEnd: (string?: string | undefined, length?: number | undefined, chars?: string | undefined) => string;
    readonly partial: lodash.Partial;
    readonly pick: {
        <T extends object, U extends keyof T>(object: T | null | undefined, ...props: lodash.Many<U>[]): Pick<T, U>;
        <T>(object: T | null | undefined, ...props: lodash.Many<PropertyKey>[]): lodash.PartialDeep<T>;
    };
    readonly pickBy: <T extends object>(object: T | null | undefined, predicate?: string | [string, any] | ((value: T[keyof T], key: string) => lodash.NotVoid) | lodash.PartialDeep<T[keyof T]> | undefined) => Partial<T>;
    readonly property: <TObj, TResult>(path: lodash.Many<PropertyKey>) => (obj: TObj) => TResult;
    readonly result: <TResult>(object: any, path: lodash.Many<PropertyKey>, defaultValue?: TResult | ((...args: any[]) => TResult) | undefined) => TResult;
    readonly set: {
        <T extends object>(object: T, path: lodash.Many<PropertyKey>, value: any): T;
        <TResult>(object: object, path: lodash.Many<PropertyKey>, value: any): TResult;
    };
    readonly sortBy: {
        <T>(collection: ArrayLike<T> | null | undefined, ...iteratees: lodash.Many<lodash.ListIteratee<T>>[]): T[];
        <T extends object>(collection: T | null | undefined, ...iteratees: lodash.Many<lodash.ObjectIteratee<T>>[]): T[keyof T][];
    };
    readonly sortedUniqBy: {
        (array: string | null | undefined, iteratee: lodash.StringIterator<lodash.NotVoid>): string[];
        <T>(array: ArrayLike<T> | null | undefined, iteratee: lodash.ListIteratee<T>): T[];
    };
    readonly uniq: <T>(array: ArrayLike<T> | null | undefined) => T[];
    readonly uniqBy: {
        (array: string | null | undefined, iteratee: lodash.StringIterator<lodash.NotVoid>): string[];
        <T>(array: ArrayLike<T> | null | undefined, iteratee: lodash.ListIteratee<T>): T[];
    };
    readonly zipObject: {
        <T>(props: ArrayLike<PropertyKey>, values: ArrayLike<T>): lodash.Dictionary<T>;
        (props?: ArrayLike<PropertyKey> | undefined): lodash.Dictionary<undefined>;
    };
};
export default _default;
